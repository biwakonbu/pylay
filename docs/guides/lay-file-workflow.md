# .lay.* ファイルのワークフローガイド

このガイドでは、pylayが生成する `.lay.py` / `.lay.yaml` ファイルの使い方と、プロジェクトでの運用方法を説明します。

## 目次

- [概要](#概要)
- [基本概念](#基本概念)
- [ワークフロー](#ワークフロー)
- [ベストプラクティス](#ベストプラクティス)
- [よくある質問](#よくある質問)

## 概要

### .lay.* ファイルとは

`.lay.py` / `.lay.yaml` は、pylayが自動生成するファイルを識別するための拡張子です。

```
プロジェクト/
├── src/
│   ├── models.py           # 手動実装（あなたが書くコード）
│   ├── types.lay.py        # pylay自動生成（Pythonコード）
│   └── api.py              # 手動実装
└── docs/
    └── pylay/
        └── src/
            ├── models.lay.yaml  # pylay自動生成（YAML）
            └── api.lay.yaml     # pylay自動生成（YAML）
```

### 設計思想

pylayは、Django ORM（models.py）やRails（schema.rb）と同様の「battery included」アプローチを採用しています：

- **明示的な命名規則**: `.lay.*` = pylayが自動生成
- **Git管理推奨**: 変更履歴を追跡し、チームで共有
- **クリーン再生成**: 古いファイルを削除してから新規生成

## 基本概念

### 1. ファイルの種類

#### .lay.py（Python型定義ファイル）

YAML型仕様からPydantic BaseModelを生成します。

```python
"""
====================================
pylay自動生成ファイル
このファイルを直接編集しないでください
次回の pylay types 実行時に削除・再生成されます
====================================
Generated by: pylay types specs/api.yaml
Source: specs/api.yaml
Generated at: 2025-10-07T16:26:28.219620+00:00
"""

from pydantic import BaseModel

class User(BaseModel):
    """ユーザー情報"""
    user_id: str
    name: str
    email: str
```

**用途**:
- API型定義のコード生成
- データモデルの自動生成
- 型チェック（mypy, pyright）

#### .lay.yaml（YAML型仕様ファイル）

Python型定義からYAML形式の型仕様を生成します。

```yaml
# ====================================
# pylay自動生成ファイル
# このファイルを直接編集しないでください
# 次回の pylay yaml 実行時に削除・再生成されます
# ====================================
# Generated by: pylay yaml src/models.py
# Source: src/models.py
# Generated at: 2025-10-07T16:32:38.327795+00:00

User:
  type: dict
  description: ユーザー情報
  properties:
    user_id:
      type: str
      required: true
    name:
      type: str
      required: true
    email:
      type: str
      required: true
```

**用途**:
- 型定義のドキュメント化
- 型定義の共有（他言語チーム、APIドキュメント）
- バージョン管理による変更履歴の追跡

### 2. 警告ヘッダー

すべての `.lay.*` ファイルには、ファイル先頭に警告ヘッダーが自動挿入されます。

**目的**:
1. **編集禁止の明示**: 手動編集を防ぐ
2. **所有権の明確化**: pylayが生成したファイルと識別
3. **トレーサビリティ**: ソースファイルと生成日時を記録

## ワークフロー

### 基本的な開発フロー

#### 1. プロジェクト初期化

```bash
cd my-project
pylay init
```

`pyproject.toml` に以下の設定が追加されます：

```toml
[tool.pylay]
target_dirs = ['src']
exclude_patterns = ['**/tests/**', '**/*_test.py', '**/__pycache__/**']

[tool.pylay.generation]
lay_suffix = ".lay.py"
lay_yaml_suffix = ".lay.yaml"
add_generation_header = true
include_source_path = true

[tool.pylay.output]
yaml_output_dir = "docs/pylay"
mirror_package_structure = true
```

#### 2. Python型からYAML生成

```bash
# 単一ファイル
pylay yaml src/models.py -o types

# パッケージ構造を保持
pylay yaml src/core/schemas/user.py
# → docs/pylay/src/core/schemas/user.lay.yaml が生成される
```

**何が起こるか**:
1. `src/models.py` をインポート
2. Pydantic BaseModelとEnumを検出
3. YAML型仕様に変換
4. 警告ヘッダーを追加
5. `docs/pylay/types.lay.yaml` に出力

#### 3. YAMLからPython型生成

```bash
# API仕様からモデル生成
pylay types specs/api.yaml -o src/generated/models

# 拡張子は自動付与
pylay types specs/api.yaml -o src/generated/models
# → src/generated/models.lay.py が生成される
```

**何が起こるか**:
1. `specs/api.yaml` を読み込み
2. YAML型仕様をパース
3. Pydantic BaseModelを生成
4. 警告ヘッダーを追加
5. `src/generated/models.lay.py` に出力

#### 4. 型定義の更新

```bash
# 手動実装ファイルを編集
vim src/models.py

# YAML型仕様を再生成
pylay yaml src/models.py -o types
# → types.lay.yaml が更新される

# Gitにコミット
git add src/models.py docs/pylay/types.lay.yaml
git commit -m "feat: User型にageフィールドを追加"
```

### クリーン再生成フロー

古い `.lay.*` ファイルを削除してから新規生成する場合：

```python
from pathlib import Path
from src.core.converters.clean_regeneration import clean_lay_files

# 出力ディレクトリの古い.lay.pyファイルを削除
output_dir = Path("src/generated")
deleted = clean_lay_files(output_dir, ".lay.py")
print(f"削除されたファイル: {len(deleted)}個")

# 新規生成
# pylay types specs/api.yaml -o src/generated/models
```

**安全性**:
- 警告ヘッダーがあるファイルのみ削除
- 手動実装ファイルは保護される

## ベストプラクティス

### 1. Git管理の推奨

`.lay.*` ファイルを `.gitignore` に追加**しない**でください。

**理由**:
- 型定義の変更履歴を追跡できる
- PRで自動生成コードの差分を確認できる
- CI/CDでの自動生成との差異を検出できる
- チームメンバーが最新の型定義を共有できる

```gitignore
# ❌ 非推奨
*.lay.py
*.lay.yaml

# ✅ 推奨（.lay.*ファイルは通常のファイルとして管理）
```

### 2. ディレクトリ構造

Django風の「小さなパッケージ」アプローチを推奨：

```
src/
├── users/
│   ├── models.py        # 手動実装（Pydantic BaseModel）
│   ├── types.lay.py     # pylay生成（型定義のみ）
│   ├── api.py           # 手動実装（FastAPI）
│   └── services.py      # 手動実装（ビジネスロジック）
└── products/
    ├── models.py
    ├── types.lay.py
    ├── api.py
    └── services.py
```

### 3. ファイル命名規則

```bash
# ✅ 推奨
types.lay.py        # 型定義ファイル
models.lay.yaml     # YAMLモデル定義
schemas.lay.py      # スキーマ定義

# ❌ 非推奨（拡張子なし）
types.py            # 手動実装ファイルと区別がつかない
models.yaml         # pylayが生成したか不明
```

### 4. CI/CDでの活用

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Install dependencies
        run: uv sync

      - name: Generate types
        run: |
          uv run pylay yaml src/models.py -o docs/pylay/models

      - name: Check for uncommitted changes
        run: |
          git diff --exit-code docs/pylay/
          # → .lay.yamlファイルに差分があればCIが失敗
```

### 5. ドキュメント生成

```bash
# 型定義ドキュメントを生成
pylay docs src/models.py -o docs/api

# 生成されたドキュメント
docs/
├── api/
│   ├── models.md        # 手動編集可能
│   └── types.lay.md     # pylay生成（自動更新）
└── pylay/
    └── models.lay.yaml  # 型仕様（Git管理）
```

## よくある質問

### Q1: .lay.* ファイルを手動編集してもいいですか？

**A**: いいえ、推奨しません。

`.lay.*` ファイルは次回の `pylay` コマンド実行時に削除・再生成されます。手動編集は失われます。

**代わりに**:
1. 元のソースファイル（`models.py`, `api.yaml`）を編集
2. `pylay` コマンドで再生成

### Q2: .lay.* ファイルを .gitignore に追加すべきですか？

**A**: いいえ、Git管理を推奨します。

**理由**:
- 型定義の変更履歴を追跡
- チームでの型定義共有
- PRでのレビュー容易性

**例外**: プロジェクトポリシーで自動生成ファイルのGit管理を禁止している場合のみ

### Q3: 既存の型定義ファイルを .lay.py にリネームすべきですか？

**A**: ケースバイケースです。

**リネーム推奨**:
- pylayで自動生成する予定のファイル
- 頻繁に更新される型定義

**リネーム不要**:
- 手動実装のビジネスロジック
- 複雑なカスタム型定義

### Q4: .lay.py ファイルを import できますか？

**A**: はい、通常のPythonファイルと同様に import できます。

```python
# types.lay.py
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int

# api.py（手動実装）
from .types import User  # types.lay.py から import

def create_user(user: User) -> User:
    # ビジネスロジック
    return user
```

### Q5: クリーン再生成は自動実行されますか？

**A**: 現在は手動実行が必要です。

```python
from src.core.converters.clean_regeneration import clean_lay_files

# 古い.lay.pyファイルを削除
clean_lay_files(output_dir, ".lay.py")
```

**将来の実装予定**:
- `--clean` オプションで自動クリーン再生成
- TUIでのワンクリック再生成

### Q6: パッケージ構造はどのようにミラーリングされますか？

**A**: 入力ファイルのプロジェクト内での相対位置を保持します。

```bash
# 入力
src/core/schemas/user.py

# 出力（自動的にミラーリング）
docs/pylay/src/core/schemas/user.lay.yaml
```

## 関連ドキュメント

- [クリーン再生成ガイド](./clean-regeneration.md)
- [型定義ルール](../typing-rule.md)
- [開発ガイドライン](../../AGENTS.md)

---

🤖 このガイドはpylayプロジェクトの一部です。
