# ====================================
# pylay自動生成ファイル
# このファイルを直接編集しないでください
# 次回の pylay yaml 実行時に削除・再生成されます
# ====================================
# Generated by: pylay yaml /home/biwakonbu/github/pylay/src/core/schemas/graph.py
# Source: /home/biwakonbu/github/pylay/src/core/schemas/graph.py
# Generated at: 2025-10-08T10:42:38.129449+00:00

_metadata:
  generated_by: pylay yaml
  source: /home/biwakonbu/github/pylay/src/core/schemas/graph.py
  generated_at: 2025-10-08T10:42:38.130090+00:00
  pylay_version: 0.5.0

RelationType:
  type: dict
  description: 関係の種類を定義する列挙型
  required: true
  properties: {}
  additional_properties: false
GraphNode:
  type: dict
  description: "グラフのノードを表すクラス\n\nAttributes:\n    id: ノードの一意の識別子 (自動生成可能)\n    name:
    ノードの名前\n    node_type: ノードの種類\n    qualified_name: 完全修飾名\n    attributes: ノードの追加属性"
  required: true
  properties:
    id:
      name: Union[NodeId, NoneType]
      type: union
      description: "Represent a PEP 604 union type\n\nE.g. for int | str"
      required: true
      variants:
      - NodeId
      - NoneType
    name:
      name: str
      type: str
      description: "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]])
        -> str\n\nCreate a new string object from the given object. If encoding or\n\
        errors is specified, then the object must expose a data buffer\nthat will
        be decoded using the given encoding and error handler.\nOtherwise, returns
        the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults
        to 'utf-8'.\nerrors defaults to 'strict'."
      required: true
    node_type:
      name: NodeType
      type: dict
      description: "Type alias.\n\nType aliases are created through the type statement::\n\
        \n    type Alias = int\n\nIn this example, Alias and int will be treated equivalently
        by static\ntype checkers.\n\nAt runtime, Alias is an instance of TypeAliasType.
        The __name__\nattribute holds the name of the type alias. The value of the
        type alias\nis stored in the __value__ attribute. It is evaluated lazily,
        so the\nvalue is computed only if the attribute is accessed.\n\nType aliases
        can also be generic::\n\n    type ListOrSet[T] = list[T] | set[T]\n\nIn this
        case, the type parameters of the alias are stored in the\n__type_params__
        attribute.\n\nSee PEP 695 for more information."
      required: true
      properties: {}
      additional_properties: false
    qualified_name:
      name: Union[QualifiedName, NoneType]
      type: union
      description: "Represent a PEP 604 union type\n\nE.g. for int | str"
      required: true
      variants:
      - QualifiedName
      - NoneType
    attributes:
      name: Union[NodeAttributes, NoneType]
      type: union
      description: "Represent a PEP 604 union type\n\nE.g. for int | str"
      required: true
      variants:
      - NodeAttributes
      - NoneType
    source_file:
      name: Union[FilePath, NoneType]
      type: union
      description: "Represent a PEP 604 union type\n\nE.g. for int | str"
      required: true
      variants:
      - FilePath
      - NoneType
    line_number:
      name: Union[LineNumber, NoneType]
      type: union
      description:
      required: true
      variants:
      - LineNumber
      - NoneType
  additional_properties: false
GraphEdge:
  type: dict
  description: "グラフのエッジを表すクラス\n\nAttributes:\n    source: 始点ノードのID\n    target: 終点ノードのID\n\
    \    relation_type: 関係の種類\n    weight: エッジの重み\n    attributes: エッジの追加属性"
  required: true
  properties:
    source:
      name: NodeId
      type: dict
      description: "Type alias.\n\nType aliases are created through the type statement::\n\
        \n    type Alias = int\n\nIn this example, Alias and int will be treated equivalently
        by static\ntype checkers.\n\nAt runtime, Alias is an instance of TypeAliasType.
        The __name__\nattribute holds the name of the type alias. The value of the
        type alias\nis stored in the __value__ attribute. It is evaluated lazily,
        so the\nvalue is computed only if the attribute is accessed.\n\nType aliases
        can also be generic::\n\n    type ListOrSet[T] = list[T] | set[T]\n\nIn this
        case, the type parameters of the alias are stored in the\n__type_params__
        attribute.\n\nSee PEP 695 for more information."
      required: true
      properties: {}
      additional_properties: false
    target:
      name: NodeId
      type: dict
      description: "Type alias.\n\nType aliases are created through the type statement::\n\
        \n    type Alias = int\n\nIn this example, Alias and int will be treated equivalently
        by static\ntype checkers.\n\nAt runtime, Alias is an instance of TypeAliasType.
        The __name__\nattribute holds the name of the type alias. The value of the
        type alias\nis stored in the __value__ attribute. It is evaluated lazily,
        so the\nvalue is computed only if the attribute is accessed.\n\nType aliases
        can also be generic::\n\n    type ListOrSet[T] = list[T] | set[T]\n\nIn this
        case, the type parameters of the alias are stored in the\n__type_params__
        attribute.\n\nSee PEP 695 for more information."
      required: true
      properties: {}
      additional_properties: false
    relation_type:
      name: RelationType
      type: dict
      description: 関係の種類を定義する列挙型
      required: true
      properties: {}
      additional_properties: false
    weight:
      name: Weight
      type: dict
      description: "NewType creates simple unique types with almost zero runtime overhead.\n\
        \nNewType(name, tp) is considered a subtype of tp\nby static type checkers.
        At runtime, NewType(name, tp) returns\na dummy callable that simply returns
        its argument.\n\nUsage::\n\n    UserId = NewType('UserId', int)\n\n    def
        name_by_id(user_id: UserId) -> str:\n        ...\n\n    UserId('user')   \
        \       # Fails type check\n\n    name_by_id(42)          # Fails type check\n\
        \    name_by_id(UserId(42))  # OK\n\n    num = UserId(5) + 1     # type: int"
      required: true
      properties: {}
      additional_properties: false
    attributes:
      name: Union[NodeAttributes, NoneType]
      type: union
      description: "Represent a PEP 604 union type\n\nE.g. for int | str"
      required: true
      variants:
      - NodeAttributes
      - NoneType
    metadata:
      name: Union[GraphMetadata, NoneType]
      type: union
      description: "Represent a PEP 604 union type\n\nE.g. for int | str"
      required: true
      variants:
      - GraphMetadata
      - NoneType
  additional_properties: false
TypeDependencyGraph:
  type: dict
  description: "型依存関係グラフを表すクラス\n\nAttributes:\n    nodes: グラフ内の全てのノード\n    edges:
    グラフ内の全てのエッジ\n    metadata: グラフのメタデータ"
  required: true
  properties:
    nodes:
      name: list
      type: list
      description: "Built-in mutable sequence.\n\nIf no argument is given, the constructor
        creates a new empty list.\nThe argument must be an iterable if specified."
      required: true
      items: GraphNode
    edges:
      name: list
      type: list
      description: "Built-in mutable sequence.\n\nIf no argument is given, the constructor
        creates a new empty list.\nThe argument must be an iterable if specified."
      required: true
      items: GraphEdge
    metadata:
      name: Union[GraphMetadata, NoneType]
      type: union
      description: "Represent a PEP 604 union type\n\nE.g. for int | str"
      required: true
      variants:
      - GraphMetadata
      - NoneType
    inferred_nodes:
      name: Union[list, NoneType]
      type: union
      description: "Represent a PEP 604 union type\n\nE.g. for int | str"
      required: true
      variants:
      - name: list
        type: list
        description: "Built-in mutable sequence.\n\nIf no argument is given, the constructor
          creates a new empty list.\nThe argument must be an iterable if specified."
        required: true
        items: GraphNode
      - NoneType
  additional_properties: false
