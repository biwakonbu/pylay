---
description: Pythonファイルの型解析、型修正、型アノテーションの追加/修正時に自動適用。pylayプロジェクトの型定義ルール（docs/typing-rule.md）に準拠し、Python 3.13標準型システムとPydanticを活用した型安全性を提供。
alwaysApply: false
---
# Python型アノテーションの近代的ルールと型安全性ガイドライン

## ⚠️ 重要: プロジェクト固有の型定義ルール

**このファイルは一般的なPython型アノテーションガイドラインです。**
**pylayプロジェクト固有の型定義ルールは [docs/typing-rule.md](../../docs/typing-rule.md) を必ず参照してください。**

### pylayプロジェクトの4つの核心原則

1. **個別型をちゃんと定義し、primitive型を直接使わない**
   - ❌ `str`, `int` → ✅ ドメイン型を定義（`NewType` + `Annotated`、`dataclass`、`BaseModel`）

2. **Pydanticによる厳密な型定義でドメイン型を作成する**
   - **3つのレベルを適切に使い分ける**：
     - Level 1: `type` エイリアス（制約なし）
     - Level 2: `NewType` + `Annotated` + (`Field` | `AfterValidator`)（★プリミティブ型代替、最頻出）
     - Level 3: `dataclass` + Pydantic または `BaseModel`（複雑なドメイン型）
       - 3a: `dataclass(frozen=True)` - 不変値オブジェクト
       - 3b: `dataclass` - 状態管理エンティティ
       - 3c: `BaseModel` - 複雑なドメインモデル

3. **typing モジュールは必要最小限に留める（Python 3.13標準を優先）**
   - ❌ `Union[X, Y]` → ✅ `X | Y`
   - ❌ `List[X]` → ✅ `list[X]`
   - ❌ `TypeVar('T')` + `Generic[T]` → ✅ `class Container[T]`
   - ❌ `TypeAlias` → ✅ `type Point = tuple[float, float]`
   - ✅ `NewType` - Level 2で型レベル区別のために使用

4. **型と実装を分離し、循環参照を防ぐ**
   - `types.py`: 型定義のみ（Level 1/2を優先）
   - `protocols.py`: Protocolインターフェース定義
   - `models.py`: ドメインモデル（Level 3: dataclass/BaseModel）
   - `services.py`: ビジネスロジック実装

**詳細**: [docs/typing-rule.md](../../docs/typing-rule.md)

---

## 基本原則（一般ガイドライン）

- **型安全性を最優先**: `Any`型や構造化されていない辞書の使用を避ける
- **近代的な型アノテーション**: Python 3.13標準の`X | Y`構文を使用（`Union[X, Y]`禁止）
- **ドメイン境界の明確化**: プリミティブ型をそのまま使用せず、Pydantic BaseModelでドメイン型を定義
- **詳細なdocstring**: 型からドキュメントを自動生成するため、型定義には詳細な説明をdocstringで記述

## Pydantic型システムの活用

### BaseModel - 主要なデータモデル基底クラス

Pydantic v2の`BaseModel`は、データ検証・変換・シリアライズを自動的に行う強力な基底クラスです：

```python
from pydantic import BaseModel, Field
from typing import Literal

class UserProfile(BaseModel):
    """ユーザー情報モデル"""
    id: int = Field(..., description="ユーザーID")
    name: str = Field(..., min_length=1, max_length=100)
    email: str = Field(..., pattern=r"^[^@]+@[^@]+\.[^@]+$")
    role: Literal["admin", "user", "moderator"] = "user"

# 使用例
user = UserProfile(id=123, name="田中太郎", email="tanaka@example.com")
print(user.model_dump())  # 検証済みデータを辞書に変換
```

### RootModel - カスタムルートタイプ

単一の値やコレクションをルートとするモデル：

```python
from pydantic import RootModel

class StringList(RootModel[list[str]]):
    """文字列リストのRootModel"""
    root: list[str]
```

### PrivateAttr - プライベート属性

検証されないプライベート属性：

```python
from pydantic import BaseModel, PrivateAttr

class UserWithCache(BaseModel):
    id: int
    name: str
    _cache_hit_count: int = PrivateAttr(default=0)
```

### Field - フィールド設定

詳細なフィールド制約：

```python
from pydantic import BaseModel, Field

class Product(BaseModel):
    name: str = Field(..., min_length=1, max_length=100, description="商品名")
    price: float = Field(..., gt=0, description="価格")
    tags: list[str] = Field(default_factory=list, description="タグ")
```

### Pydantic設定管理

環境変数からの設定読み込み：

```python
from pydantic import BaseModel, Field
from pydantic_settings import BaseSettings

class DatabaseConfig(BaseModel):
    host: str = Field(default="localhost")
    port: int = Field(default=5432, ge=1, le=65535)
    database: str = Field(..., min_length=1)
    user: str = Field(..., min_length=1)

class AppSettings(BaseSettings):
    database: DatabaseConfig = Field(default_factory=DatabaseConfig)
    debug: bool = Field(default=False)

    class Config:
        env_nested_delimiter = "__"
        env_prefix = "APP_"
```

### Pydantic Types - 組み込み型と変換

Pydantic v2の組み込み型で自動検証・変換：

```python
from pydantic import BaseModel
from pydantic.types import EmailStr, HttpUrl
from uuid import UUID

class Contact(BaseModel):
    """連絡先モデル - Pydantic Types使用例"""
    id: UUID  # UUID変換
    email: EmailStr  # メール検証
    website: HttpUrl  # URL検証
```

### Unions & Validators - 複数型とカスタム検証

Unionで複数型を許可し、@field_validatorでカスタムルール：

```python
from pydantic import BaseModel, Field, field_validator
from typing import Union

class FlexibleData(BaseModel):
    """柔軟なデータモデル - UnionとValidator"""
    value: Union[str, int, float]  # 複数型
    mode: str = "auto"

    @field_validator('value')
    @classmethod
    def validate_value(cls, v):
        if isinstance(v, str) and len(v) > 10:
            raise ValueError("String too long")
        return v
```

### Strict Mode - 厳格検証

型変換を無効化し、厳格に検証：

```python
from pydantic import BaseModel, ConfigDict

class StrictModel(BaseModel):
    model_config = ConfigDict(strict=True)
    value: int  # str → int 変換を無効化
```

### Generic Models & Type Adapter - ジェネリックと軽量検証

Genericで再利用可能なモデル、TypeAdapterで軽量検証：

```python
from pydantic import BaseModel, TypeAdapter
from typing import Generic, TypeVar

T = TypeVar('T')

class Response(BaseModel, Generic[T]):
    data: T
    status: str
```

### Serialization & JSON Schema - 出力とスキーマ生成

model_dump()で出力制御、model_json_schema()でスキーマ生成：

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str
    age: int = Field(alias="user_age")

user = User(name="太郎", user_age=30)
print(user.model_dump(by_alias=True))
```

### Error Handling - エラー処理

ValidationErrorの詳細ハンドリング：

```python
from pydantic import BaseModel, ValidationError, Field

class Product(BaseModel):
    name: str
    price: float = Field(gt=0)
```

### Dataclasses & Forward Refs - Dataclass統合と循環参照

@dataclass + Pydantic、Forward Refsで循環参照解決：

```python
from pydantic.dataclasses import dataclass

@dataclass
class ProductDataclass:
    name: str
    price: float
```

## ドメイン型システム（pylayプロジェクト）

**重要**: pylayプロジェクトでは**3つのレベル**を適切に使い分けます：
- Level 1: `type` エイリアス（制約なし）
- Level 2: `NewType` + `Annotated` + (`Field` | `AfterValidator`)（★プリミティブ型代替、最頻出）
- Level 3: `dataclass` + Pydantic または `BaseModel`（複雑なドメイン型）

詳細は [docs/typing-rule.md](../../docs/typing-rule.md) の「型定義の3つのレベル」を参照してください。

### 1. Level 2: NewType + Annotated（プリミティブ型代替、最頻出パターン）

制約付きの単一値型には `NewType` + `Annotated` を使用します：

```python
from typing import NewType, Annotated
from pydantic import AfterValidator, Field, BaseModel

# バリデータ関数の定義
def validate_module_name(v: str) -> str:
    """モジュール名のバリデーション"""
    if not v.islower():
        raise ValueError("モジュール名は小文字のみで構成してください")
    if not v.replace("_", "").isalnum():
        raise ValueError("モジュール名は英数字とアンダースコアのみです")
    return v

def validate_type_name(v: str) -> str:
    """型名のバリデーション"""
    if not v[0].isupper():
        raise ValueError("型名は大文字で始まる必要があります")
    return v

# NewType + Annotated型の定義（再利用可能）
ModuleName = NewType(
    'ModuleName',
    Annotated[
        str,
        AfterValidator(validate_module_name),
        Field(min_length=1, pattern=r"^[a-z][a-z0-9_]*$", description="Pythonモジュール名")
    ]
)

TypeName = NewType(
    'TypeName',
    Annotated[
        str,
        AfterValidator(validate_type_name),
        Field(min_length=1, pattern=r"^[A-Za-z_][A-Za-z0-9_]*$", description="型名")
    ]
)

# Field のみのパターン
YamlPath = NewType(
    'YamlPath',
    Annotated[str, Field(min_length=1, pattern=r"\.ya?ml$", description="YAML型仕様ファイルパス")]
)

Count = NewType('Count', Annotated[int, Field(ge=0)])

# Pydantic BaseModelで使用
class TypeSpec(BaseModel):
    """型仕様"""
    name: TypeName  # 自動的にバリデーションされる
    module: ModuleName
    yaml_path: YamlPath | None = None
```

### 2. Level 3: dataclass + Pydantic または BaseModel

複雑なビジネスロジックや複数フィールドを持つドメイン型：

**Pattern A: dataclass(frozen=True) - 不変値オブジェクト**
```python
from dataclasses import dataclass
from pydantic import Field

@dataclass(frozen=True)
class CodeLocation:
    """コード位置を表す値オブジェクト"""
    file: str = Field(min_length=1)
    line: int = Field(ge=1)
    column: int = Field(ge=0, default=0)

    def format_display(self) -> str:
        """表示用フォーマット"""
        return f"{self.file}:{self.line}:{self.column}"
```

**Pattern B: BaseModel - 複雑なドメインモデル**
```python
from pydantic import BaseModel, Field, model_validator

class ModuleAnalysisResult(BaseModel):
    """モジュール解析結果（複雑なドメイン型）"""
    module_name: ModuleName  # Level 2の型を活用
    total_lines: int = Field(ge=0)
    code_lines: int = Field(ge=0)
    comment_lines: int = Field(ge=0)

    @model_validator(mode="after")
    def validate_line_counts(self) -> "ModuleAnalysisResult":
        """不変条件の検証"""
        if self.total_lines < self.code_lines + self.comment_lines:
            raise ValueError("行数の整合性エラー")
        return self

    def is_well_documented(self) -> bool:
        """適切にドキュメント化されているか判定（ビジネスロジック）"""
        if self.code_lines == 0:
            return True
        return self.comment_lines / self.code_lines >= 0.2
```

### 3. Entity（エンティティ）パターン

識別子を持つドメインオブジェクト：

```python
from pydantic import BaseModel, Field
from typing import Literal, Any

# pylayプロジェクトの既存の型定義例
class GraphNode(BaseModel):
    """グラフのノードを表すエンティティ

    Attributes:
        id: ノードの一意の識別子
        name: ノードの名前
        node_type: ノードの種類
        qualified_name: 完全修飾名
    """
    id: str | None = None
    name: str = Field(..., min_length=1)
    node_type: Literal["class", "function", "module"] | str
    qualified_name: str | None = None

    def __init__(self, **data: Any) -> None:
        super().__init__(**data)
        if self.id is None:
            self.id = self.name
```

### 3. Configuration（設定）パターン

アプリケーション設定を型安全に管理：

```python
from pydantic import BaseModel, Field, ConfigDict
from typing import Literal

class InferenceConfig(BaseModel):
    """型推論設定の強い型定義

    Attributes:
        infer_level: 推論レベル
        max_depth: 最大探索深度
        enable_mypy: mypy統合を有効化
        timeout: タイムアウト（秒）
    """
    model_config = ConfigDict(frozen=True)  # 設定は不変

    infer_level: Literal["loose", "normal", "strict"] = "normal"
    max_depth: int = Field(default=10, ge=1, le=100)
    enable_mypy: bool = True
    timeout: int = Field(default=60, ge=1, le=600)
```

### 4. Enum（列挙型）パターン

固定された選択肢を型安全に定義：

```python
from enum import Enum

class RelationType(str, Enum):
    """関係の種類を定義する列挙型"""

    DEPENDS_ON = "depends_on"
    INHERITS_FROM = "inherits_from"
    IMPLEMENTS = "implements"
    REFERENCES = "references"
    USES = "uses"
    RETURNS = "returns"
    CALLS = "calls"
```

### 5. エラーハンドリング型

型安全なエラーハンドリング：

```python
from pydantic import BaseModel, Field
from typing import Generic, TypeVar, Literal

T = TypeVar('T')

class Result(Generic[T]):
    """成功/失敗を表すResult型"""
    def __init__(self, success: T | None = None, error: str | None = None):
        self.success = success
        self.error = error

class BaseGenerationError(BaseModel):
    """LP生成関連エラーの基底クラス"""
    message: str
    context: dict[str, str | int | float | bool | None] = Field(default_factory=dict)

class WorkflowError(BaseGenerationError):
    """ワークフローエラー"""
    error_type: Literal["workflow"] = "workflow"
    activity_name: str | None = None
```

## 型アノテーションの近代化

### ✅ 使用推奨
```python
# 近代的なUnion表記
def process_data(data: str | int | None) -> dict[str, str]:
    pass

# ジェネリック型の近代表記
from collections.abc import Sequence
def get_items() -> list[str]:
    pass

# リテラル型
from typing import Literal
def set_mode(mode: Literal["auto", "manual"]) -> None:
    pass
```

### ❌ 使用禁止
```python
# 古いUnion表記（禁止）
from typing import Union
def process_data(data: Union[str, int, None]) -> Dict[str, str]:
    pass

# 古いジェネリック型（禁止）
from typing import List, Dict
def get_items() -> List[str]:
    pass
```

## Any型使用ガイドライン

### ❌ 原則禁止
```python
# 型チェックを無効化するため使用禁止
def unsafe_function(data: Any) -> Any:
    return data["key"]  # ランタイムエラー発生の可能性
```

### ✅ 例外的に許可される場合
```python
# 外部ライブラリの型不備の場合のみ
# TODO: 型安全化 - 外部ライブラリの型定義が不完全
def handle_external_api(response: dict[str, Any]) -> None:
    pass

# レガシーコードの互換性維持の場合
# TODO: 型安全化 - レガシーAPI対応のため
def legacy_adapter(data: Any) -> str:
    return str(data)
```

### Any型使用時のベストプラクティス

1. **影響範囲の局所化**: Any型は関数/メソッドの境界で型安全な構造に変換する
2. **Pydantic活用**: 外部データの場合はPydanticで段階的にバリデーション
3. **TODOコメント**: Any型使用時は必ず改善計画を明記

```python
# TODO: Any型影響範囲最小化 - アダプタークラス導入予定
def legacy_function(data: dict[str, Any]) -> dict[str, str]:
    return {"result": str(data.get("value", ""))}
```

## 型エイリアスの設計

### 共通型定義の場所
- `src/schemas/common_types.py`: 全サービス共通のNewType定義
- `src/schemas/domain_types.py`: ドメイン固有の型定義
- `src/schemas/activity_schemas.py`: アクティビティ間契約定義

### ✅ 適切な型エイリアス
```python
# 基本型エイリアス
type JSONValue = str | int | float | bool | None | list["JSONValue"] | dict[str, "JSONValue"]
type ErrorContext = dict[str, str | int | float | bool | None]

# ドメイン型エイリアス
type SEOSettings = dict[str, str | int | bool]
type TemplateConfig = dict[str, JSONValue]
```

## Pydantic vs TypedDict の使い分け（pylayプロジェクト）

### Pydanticを優先的に使用する場合（pylay推奨）
- **外部API接続**: ランタイム検証、複雑なバリデーションが必要
- **設定管理**: 環境変数からの自動読み込み（pyproject.toml読み込みなど）
- **データ変換**: 自動的な型変換・シリアライズ（YAML ↔ Python型変換）
- **ドメインモデル**: ビジネスロジックを含む複雑なモデル
- **型仕様定義**: TypeSpec、GraphNode、InferResultなど
- **JSONシリアライズ**: ドキュメント生成や永続化が必要な場合

### TypedDictを限定的に使用する場合
- **軽量な内部データ構造**: パフォーマンスが極めて重要な単純な辞書ベースの構造
- **外部APIレスポンス**: 軽量な型定義が必要な場合

```python
# ✅ Pydantic - ドメイン型定義（推奨）
class TypeSpec(BaseModel):
    """YAML型仕様のPydanticモデル"""
    name: str | None = None
    type: str = Field(..., description="基本型")
    required: bool = True

# ⚠️ TypedDict - 軽量な構造定義（限定的に使用）
class CheckSummary(TypedDict):
    """analyze_issues.pyのサマリー型"""
    total_checks: int
    successful_checks: int
```

## コレクション型の使用

### ✅ 推奨されるコレクション型
```python
from collections.abc import Sequence, Mapping

def process_items(items: Sequence[str]) -> list[str]:
    """不変シーケンス - 読み取り専用"""
    return [item.upper() for item in items]
```

## 型チェックの実行

### ローカル開発での型チェック
```bash
# バックエンドの型チェック
cd backend && make type-check

# 特定のファイルの型チェック
uv run mypy src/repositories/intention_repository.py
```

### CI/CDでの型チェック
- プルリクエスト時に自動実行
- `disallow_any_explicit = true` で厳格チェック

## 型改善の優先順位

1. **高優先度**: APIインターフェース、公開関数、データモデル
2. **中優先度**: ビジネスロジック、内部関数
3. **低優先度**: ユーティリティ関数、テストヘルパー（ただしAny禁止）

## 参考資料

- [Pydantic Models Documentation](https://docs.pydantic.dev/latest/concepts/models/)
- [Python Typing Documentation](https://docs.python.org/3/library/typing.html)
- [mypy Documentation](https://mypy.readthedocs.io/)
