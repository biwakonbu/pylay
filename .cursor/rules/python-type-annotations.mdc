---
description: Pythonãƒ•ã‚¡ã‚¤ãƒ«ã®å‹è§£æã€å‹ä¿®æ­£ã€å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®è¿½åŠ /ä¿®æ­£æ™‚ã«è‡ªå‹•é©ç”¨ã€‚pylayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å‹å®šç¾©ãƒ«ãƒ¼ãƒ«ï¼ˆdocs/typing-rule.mdï¼‰ã«æº–æ‹ ã—ã€Python 3.13æ¨™æº–å‹ã‚·ã‚¹ãƒ†ãƒ ã¨Pydanticã‚’æ´»ç”¨ã—ãŸå‹å®‰å…¨æ€§ã‚’æä¾›ã€‚
alwaysApply: false
---
# Pythonå‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®è¿‘ä»£çš„ãƒ«ãƒ¼ãƒ«ã¨å‹å®‰å…¨æ€§ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

## âš ï¸ é‡è¦: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ã®å‹å®šç¾©ãƒ«ãƒ¼ãƒ«

**ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ä¸€èˆ¬çš„ãªPythonå‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã§ã™ã€‚**
**pylayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ã®å‹å®šç¾©ãƒ«ãƒ¼ãƒ«ã¯ [docs/typing-rule.md](../../docs/typing-rule.md) ã‚’å¿…ãšå‚ç…§ã—ã¦ãã ã•ã„ã€‚**

### pylayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®4ã¤ã®æ ¸å¿ƒåŸå‰‡

1. **å€‹åˆ¥å‹ã‚’ã¡ã‚ƒã‚“ã¨å®šç¾©ã—ã€primitiveå‹ã‚’ç›´æ¥ä½¿ã‚ãªã„**
   - âŒ `str`, `int` â†’ âœ… ãƒ‰ãƒ¡ã‚¤ãƒ³å‹ã‚’å®šç¾©ï¼ˆ`type` + `Annotated`ã€`dataclass`ã€`BaseModel`ï¼‰

2. **Pydanticã«ã‚ˆã‚‹å³å¯†ãªå‹å®šç¾©ã§ãƒ‰ãƒ¡ã‚¤ãƒ³å‹ã‚’ä½œæˆã™ã‚‹**
   - **3ã¤ã®ãƒ¬ãƒ™ãƒ«ã‚’é©åˆ‡ã«ä½¿ã„åˆ†ã‘ã‚‹**ï¼š
     - Level 1: `type` ã‚¨ã‚¤ãƒªã‚¢ã‚¹ï¼ˆåˆ¶ç´„ãªã—ï¼‰
     - Level 2: `type` + `Annotated` + (`Field` | `AfterValidator`)ï¼ˆâ˜…ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ä»£æ›¿ã€æœ€é »å‡ºï¼‰
     - Level 3: `dataclass` + Pydantic ã¾ãŸã¯ `BaseModel`ï¼ˆè¤‡é›‘ãªãƒ‰ãƒ¡ã‚¤ãƒ³å‹ï¼‰
       - 3a: `dataclass(frozen=True)` - ä¸å¤‰å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
       - 3b: `dataclass` - çŠ¶æ…‹ç®¡ç†ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
       - 3c: `BaseModel` - è¤‡é›‘ãªãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«

3. **typing ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å¿…è¦æœ€å°é™ã«ç•™ã‚ã‚‹ï¼ˆPython 3.13æ¨™æº–ã‚’å„ªå…ˆï¼‰**
   - âŒ `Union[X, Y]` â†’ âœ… `X | Y`
   - âŒ `List[X]` â†’ âœ… `list[X]`
   - âŒ `TypeVar('T')` + `Generic[T]` â†’ âœ… `class Container[T]`
   - âŒ `TypeAlias` â†’ âœ… `type Point = tuple[float, float]`
   - ğŸš« `NewType` ã¯ä½¿ç”¨ã—ãªã„ï¼ˆå‹åŒºåˆ¥ã¯ Annotated/åˆ¥åã§è¡¨ç¾ï¼‰

4. **å‹ã¨å®Ÿè£…ã‚’åˆ†é›¢ã—ã€å¾ªç’°å‚ç…§ã‚’é˜²ã**
   - `types.py`: å‹å®šç¾©ã®ã¿ï¼ˆLevel 1/2ã‚’å„ªå…ˆï¼‰
   - `protocols.py`: Protocolã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
   - `models.py`: ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«ï¼ˆLevel 3: dataclass/BaseModelï¼‰
   - `services.py`: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…

**è©³ç´°**: [docs/typing-rule.md](../../docs/typing-rule.md)

---

## åŸºæœ¬åŸå‰‡ï¼ˆä¸€èˆ¬ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼‰

- **å‹å®‰å…¨æ€§ã‚’æœ€å„ªå…ˆ**: `Any`å‹ã‚„æ§‹é€ åŒ–ã•ã‚Œã¦ã„ãªã„è¾æ›¸ã®ä½¿ç”¨ã‚’é¿ã‘ã‚‹
- **è¿‘ä»£çš„ãªå‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³**: Python 3.13æ¨™æº–ã®`X | Y`æ§‹æ–‡ã‚’ä½¿ç”¨ï¼ˆ`Union[X, Y]`ç¦æ­¢ï¼‰
- **ãƒ‰ãƒ¡ã‚¤ãƒ³å¢ƒç•Œã®æ˜ç¢ºåŒ–**: ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã‚’ãã®ã¾ã¾ä½¿ç”¨ã›ãšã€Pydantic BaseModelã§ãƒ‰ãƒ¡ã‚¤ãƒ³å‹ã‚’å®šç¾©
- **è©³ç´°ãªdocstring**: å‹ã‹ã‚‰ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹ãŸã‚ã€å‹å®šç¾©ã«ã¯è©³ç´°ãªèª¬æ˜ã‚’docstringã§è¨˜è¿°

## Pydanticå‹ã‚·ã‚¹ãƒ†ãƒ ã®æ´»ç”¨

### BaseModel - ä¸»è¦ãªãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«åŸºåº•ã‚¯ãƒ©ã‚¹

Pydantic v2ã®`BaseModel`ã¯ã€ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ãƒ»å¤‰æ›ãƒ»ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã‚’è‡ªå‹•çš„ã«è¡Œã†å¼·åŠ›ãªåŸºåº•ã‚¯ãƒ©ã‚¹ã§ã™ï¼š

```python
from pydantic import BaseModel, Field
from typing import Literal

class UserProfile(BaseModel):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãƒ¢ãƒ‡ãƒ«"""
    id: int = Field(..., description="ãƒ¦ãƒ¼ã‚¶ãƒ¼ID")
    name: str = Field(..., min_length=1, max_length=100)
    email: str = Field(..., pattern=r"^[^@]+@[^@]+\.[^@]+$")
    role: Literal["admin", "user", "moderator"] = "user"

# ä½¿ç”¨ä¾‹
user = UserProfile(id=123, name="ç”°ä¸­å¤ªéƒ", email="tanaka@example.com")
print(user.model_dump())  # æ¤œè¨¼æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚’è¾æ›¸ã«å¤‰æ›
```

### RootModel - ã‚«ã‚¹ã‚¿ãƒ ãƒ«ãƒ¼ãƒˆã‚¿ã‚¤ãƒ—

å˜ä¸€ã®å€¤ã‚„ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ«ãƒ¼ãƒˆã¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ï¼š

```python
from pydantic import RootModel

class StringList(RootModel[list[str]]):
    """æ–‡å­—åˆ—ãƒªã‚¹ãƒˆã®RootModel"""
    root: list[str]
```

### PrivateAttr - ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆå±æ€§

æ¤œè¨¼ã•ã‚Œãªã„ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆå±æ€§ï¼š

```python
from pydantic import BaseModel, PrivateAttr

class UserWithCache(BaseModel):
    id: int
    name: str
    _cache_hit_count: int = PrivateAttr(default=0)
```

### Field - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®š

è©³ç´°ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆ¶ç´„ï¼š

```python
from pydantic import BaseModel, Field

class Product(BaseModel):
    name: str = Field(..., min_length=1, max_length=100, description="å•†å“å")
    price: float = Field(..., gt=0, description="ä¾¡æ ¼")
    tags: list[str] = Field(default_factory=list, description="ã‚¿ã‚°")
```

### Pydanticè¨­å®šç®¡ç†

ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ã®è¨­å®šèª­ã¿è¾¼ã¿ï¼š

```python
from pydantic import BaseModel, Field
from pydantic_settings import BaseSettings

class DatabaseConfig(BaseModel):
    host: str = Field(default="localhost")
    port: int = Field(default=5432, ge=1, le=65535)
    database: str = Field(..., min_length=1)
    user: str = Field(..., min_length=1)

class AppSettings(BaseSettings):
    database: DatabaseConfig = Field(default_factory=DatabaseConfig)
    debug: bool = Field(default=False)

    class Config:
        env_nested_delimiter = "__"
        env_prefix = "APP_"
```

### Pydantic Types - çµ„ã¿è¾¼ã¿å‹ã¨å¤‰æ›

Pydantic v2ã®çµ„ã¿è¾¼ã¿å‹ã§è‡ªå‹•æ¤œè¨¼ãƒ»å¤‰æ›ï¼š

```python
from pydantic import BaseModel
from pydantic.types import EmailStr, HttpUrl
from uuid import UUID

class Contact(BaseModel):
    """é€£çµ¡å…ˆãƒ¢ãƒ‡ãƒ« - Pydantic Typesä½¿ç”¨ä¾‹"""
    id: UUID  # UUIDå¤‰æ›
    email: EmailStr  # ãƒ¡ãƒ¼ãƒ«æ¤œè¨¼
    website: HttpUrl  # URLæ¤œè¨¼
```

### Unions & Validators - è¤‡æ•°å‹ã¨ã‚«ã‚¹ã‚¿ãƒ æ¤œè¨¼

Unionã§è¤‡æ•°å‹ã‚’è¨±å¯ã—ã€@field_validatorã§ã‚«ã‚¹ã‚¿ãƒ ãƒ«ãƒ¼ãƒ«ï¼š

```python
from pydantic import BaseModel, Field, field_validator
from typing import Union

class FlexibleData(BaseModel):
    """æŸ”è»Ÿãªãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ« - Unionã¨Validator"""
    value: Union[str, int, float]  # è¤‡æ•°å‹
    mode: str = "auto"

    @field_validator('value')
    @classmethod
    def validate_value(cls, v):
        if isinstance(v, str) and len(v) > 10:
            raise ValueError("String too long")
        return v
```

### Strict Mode - å³æ ¼æ¤œè¨¼

å‹å¤‰æ›ã‚’ç„¡åŠ¹åŒ–ã—ã€å³æ ¼ã«æ¤œè¨¼ï¼š

```python
from pydantic import BaseModel, ConfigDict

class StrictModel(BaseModel):
    model_config = ConfigDict(strict=True)
    value: int  # str â†’ int å¤‰æ›ã‚’ç„¡åŠ¹åŒ–
```

### Generic Models & Type Adapter - ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã¨è»½é‡æ¤œè¨¼

Genericã§å†åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«ã€TypeAdapterã§è»½é‡æ¤œè¨¼ï¼š

```python
from pydantic import BaseModel, TypeAdapter
from typing import Generic, TypeVar

T = TypeVar('T')

class Response(BaseModel, Generic[T]):
    data: T
    status: str
```

### Serialization & JSON Schema - å‡ºåŠ›ã¨ã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆ

model_dump()ã§å‡ºåŠ›åˆ¶å¾¡ã€model_json_schema()ã§ã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆï¼š

```python
from pydantic import BaseModel, Field

class User(BaseModel):
    name: str
    age: int = Field(alias="user_age")

user = User(name="å¤ªéƒ", user_age=30)
print(user.model_dump(by_alias=True))
```

### Error Handling - ã‚¨ãƒ©ãƒ¼å‡¦ç†

ValidationErrorã®è©³ç´°ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼š

```python
from pydantic import BaseModel, ValidationError, Field

class Product(BaseModel):
    name: str
    price: float = Field(gt=0)
```

### Dataclasses & Forward Refs - Dataclassçµ±åˆã¨å¾ªç’°å‚ç…§

@dataclass + Pydanticã€Forward Refsã§å¾ªç’°å‚ç…§è§£æ±ºï¼š

```python
from pydantic.dataclasses import dataclass

@dataclass
class ProductDataclass:
    name: str
    price: float
```

## ãƒ‰ãƒ¡ã‚¤ãƒ³å‹ã‚·ã‚¹ãƒ†ãƒ ï¼ˆpylayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼‰

**é‡è¦**: pylayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯**3ã¤ã®ãƒ¬ãƒ™ãƒ«**ã‚’é©åˆ‡ã«ä½¿ã„åˆ†ã‘ã¾ã™ï¼š
- Level 1: `type` ã‚¨ã‚¤ãƒªã‚¢ã‚¹ï¼ˆåˆ¶ç´„ãªã—ï¼‰
- Level 2: `type` + `Annotated` + (`Field` | `AfterValidator`)ï¼ˆâ˜…ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ä»£æ›¿ã€æœ€é »å‡ºï¼‰
- Level 3: `dataclass` + Pydantic ã¾ãŸã¯ `BaseModel`ï¼ˆè¤‡é›‘ãªãƒ‰ãƒ¡ã‚¤ãƒ³å‹ï¼‰

è©³ç´°ã¯ [docs/typing-rule.md](../../docs/typing-rule.md) ã®ã€Œå‹å®šç¾©ã®3ã¤ã®ãƒ¬ãƒ™ãƒ«ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

### 1. Level 2: type + Annotatedï¼ˆãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ä»£æ›¿ã€æœ€é »å‡ºãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰

åˆ¶ç´„ä»˜ãã®å˜ä¸€å€¤å‹ã«ã¯ `type` + `Annotated` ã‚’ä½¿ç”¨ã—ã¾ã™ï¼š

```python
from typing import Annotated
from pydantic import AfterValidator, Field, BaseModel

# ãƒãƒªãƒ‡ãƒ¼ã‚¿é–¢æ•°ã®å®šç¾©
def validate_module_name(v: str) -> str:
    """ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³"""
    if not v.islower():
        raise ValueError("ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¯å°æ–‡å­—ã®ã¿ã§æ§‹æˆã—ã¦ãã ã•ã„")
    if not v.replace("_", "").isalnum():
        raise ValueError("ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¯è‹±æ•°å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®ã¿ã§ã™")
    return v

def validate_type_name(v: str) -> str:
    """å‹åã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³"""
    if not v[0].isupper():
        raise ValueError("å‹åã¯å¤§æ–‡å­—ã§å§‹ã¾ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
    return v

# type + Annotatedå‹ã®å®šç¾©ï¼ˆå†åˆ©ç”¨å¯èƒ½ï¼‰
type ModuleName = Annotated[
    str,
    AfterValidator(validate_module_name),
    Field(min_length=1, pattern=r"^[a-z][a-z0-9_]*$", description="Pythonãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å"),
]

type TypeName = Annotated[
    str,
    AfterValidator(validate_type_name),
    Field(min_length=1, pattern=r"^[A-Za-z_][A-Za-z0-9_]*$", description="å‹å"),
]

# Field ã®ã¿ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
type YamlPath = Annotated[str, Field(min_length=1, pattern=r"\.ya?ml$", description="YAMLå‹ä»•æ§˜ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹")]

type Count = Annotated[int, Field(ge=0)]

# Pydantic BaseModelã§ä½¿ç”¨
class TypeSpec(BaseModel):
    """å‹ä»•æ§˜"""
    name: TypeName  # è‡ªå‹•çš„ã«ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã•ã‚Œã‚‹
    module: ModuleName
    yaml_path: YamlPath | None = None
```

### 2. Level 3: dataclass + Pydantic ã¾ãŸã¯ BaseModel

è¤‡é›‘ãªãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚„è¤‡æ•°ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤ãƒ‰ãƒ¡ã‚¤ãƒ³å‹ï¼š

**Pattern A: dataclass(frozen=True) - ä¸å¤‰å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ**
```python
from pydantic import Field
from pydantic.dataclasses import dataclass

@dataclass(frozen=True)
class CodeLocation:
    """ã‚³ãƒ¼ãƒ‰ä½ç½®ã‚’è¡¨ã™å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ"""
    file: str = Field(min_length=1)
    line: int = Field(ge=1)
    column: int = Field(ge=0, default=0)

    def format_display(self) -> str:
        """è¡¨ç¤ºç”¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
        return f"{self.file}:{self.line}:{self.column}"
```

**Pattern B: BaseModel - è¤‡é›‘ãªãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«**
```python
from pydantic import BaseModel, Field, model_validator

class ModuleAnalysisResult(BaseModel):
    """ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è§£æçµæœï¼ˆè¤‡é›‘ãªãƒ‰ãƒ¡ã‚¤ãƒ³å‹ï¼‰"""
    module_name: ModuleName  # Level 2ã®å‹ã‚’æ´»ç”¨
    total_lines: int = Field(ge=0)
    code_lines: int = Field(ge=0)
    comment_lines: int = Field(ge=0)

    @model_validator(mode="after")
    def validate_line_counts(self) -> "ModuleAnalysisResult":
        """ä¸å¤‰æ¡ä»¶ã®æ¤œè¨¼"""
        if self.total_lines < self.code_lines + self.comment_lines:
            raise ValueError("è¡Œæ•°ã®æ•´åˆæ€§ã‚¨ãƒ©ãƒ¼")
        return self

    def is_well_documented(self) -> bool:
        """é©åˆ‡ã«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹åˆ¤å®šï¼ˆãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ï¼‰"""
        if self.code_lines == 0:
            return True
        return self.comment_lines / self.code_lines >= 0.2
```

### 3. Entityï¼ˆã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼‰ãƒ‘ã‚¿ãƒ¼ãƒ³

è­˜åˆ¥å­ã‚’æŒã¤ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼š

```python
from pydantic import BaseModel, Field
from typing import Literal, Any

# pylayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ—¢å­˜ã®å‹å®šç¾©ä¾‹
class GraphNode(BaseModel):
    """ã‚°ãƒ©ãƒ•ã®ãƒãƒ¼ãƒ‰ã‚’è¡¨ã™ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£

    Attributes:
        id: ãƒãƒ¼ãƒ‰ã®ä¸€æ„ã®è­˜åˆ¥å­
        name: ãƒãƒ¼ãƒ‰ã®åå‰
        node_type: ãƒãƒ¼ãƒ‰ã®ç¨®é¡
        qualified_name: å®Œå…¨ä¿®é£¾å
    """
    id: str | None = None
    name: str = Field(..., min_length=1)
    node_type: Literal["class", "function", "module"] | str
    qualified_name: str | None = None

    def __init__(self, **data: Any) -> None:
        super().__init__(**data)
        if self.id is None:
            self.id = self.name
```

### 3. Configurationï¼ˆè¨­å®šï¼‰ãƒ‘ã‚¿ãƒ¼ãƒ³

ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã‚’å‹å®‰å…¨ã«ç®¡ç†ï¼š

```python
from pydantic import BaseModel, Field, ConfigDict
from typing import Literal

class InferenceConfig(BaseModel):
    """å‹æ¨è«–è¨­å®šã®å¼·ã„å‹å®šç¾©

    Attributes:
        infer_level: æ¨è«–ãƒ¬ãƒ™ãƒ«
        max_depth: æœ€å¤§æ¢ç´¢æ·±åº¦
        enable_mypy: mypyçµ±åˆã‚’æœ‰åŠ¹åŒ–
        timeout: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç§’ï¼‰
    """
    model_config = ConfigDict(frozen=True)  # è¨­å®šã¯ä¸å¤‰

    infer_level: Literal["loose", "normal", "strict"] = "normal"
    max_depth: int = Field(default=10, ge=1, le=100)
    enable_mypy: bool = True
    timeout: int = Field(default=60, ge=1, le=600)
```

### 4. Enumï¼ˆåˆ—æŒ™å‹ï¼‰ãƒ‘ã‚¿ãƒ¼ãƒ³

å›ºå®šã•ã‚ŒãŸé¸æŠè‚¢ã‚’å‹å®‰å…¨ã«å®šç¾©ï¼š

```python
from enum import Enum

class RelationType(str, Enum):
    """é–¢ä¿‚ã®ç¨®é¡ã‚’å®šç¾©ã™ã‚‹åˆ—æŒ™å‹"""

    DEPENDS_ON = "depends_on"
    INHERITS_FROM = "inherits_from"
    IMPLEMENTS = "implements"
    REFERENCES = "references"
    USES = "uses"
    RETURNS = "returns"
    CALLS = "calls"
```

### 5. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å‹

å‹å®‰å…¨ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼š

```python
from pydantic import BaseModel, Field
from typing import Generic, TypeVar, Literal

T = TypeVar('T')

class Result(Generic[T]):
    """æˆåŠŸ/å¤±æ•—ã‚’è¡¨ã™Resultå‹"""
    def __init__(self, success: T | None = None, error: str | None = None):
        self.success = success
        self.error = error

class BaseGenerationError(BaseModel):
    """LPç”Ÿæˆé–¢é€£ã‚¨ãƒ©ãƒ¼ã®åŸºåº•ã‚¯ãƒ©ã‚¹"""
    message: str
    context: dict[str, str | int | float | bool | None] = Field(default_factory=dict)

class WorkflowError(BaseGenerationError):
    """ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼"""
    error_type: Literal["workflow"] = "workflow"
    activity_name: str | None = None
```

## å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã®è¿‘ä»£åŒ–

### âœ… ä½¿ç”¨æ¨å¥¨
```python
# è¿‘ä»£çš„ãªUnionè¡¨è¨˜
def process_data(data: str | int | None) -> dict[str, str]:
    pass

# ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã®è¿‘ä»£è¡¨è¨˜
from collections.abc import Sequence
def get_items() -> list[str]:
    pass

# ãƒªãƒ†ãƒ©ãƒ«å‹
from typing import Literal
def set_mode(mode: Literal["auto", "manual"]) -> None:
    pass
```

### âŒ ä½¿ç”¨ç¦æ­¢
```python
# å¤ã„Unionè¡¨è¨˜ï¼ˆç¦æ­¢ï¼‰
from typing import Union
def process_data(data: Union[str, int, None]) -> Dict[str, str]:
    pass

# å¤ã„ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ï¼ˆç¦æ­¢ï¼‰
from typing import List, Dict
def get_items() -> List[str]:
    pass
```

## Anyå‹ä½¿ç”¨ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

### âŒ åŸå‰‡ç¦æ­¢
```python
# å‹ãƒã‚§ãƒƒã‚¯ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ãŸã‚ä½¿ç”¨ç¦æ­¢
def unsafe_function(data: Any) -> Any:
    return data["key"]  # ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿã®å¯èƒ½æ€§
```

### âœ… ä¾‹å¤–çš„ã«è¨±å¯ã•ã‚Œã‚‹å ´åˆ
```python
# å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹ä¸å‚™ã®å ´åˆã®ã¿
# TODO: å‹å®‰å…¨åŒ– - å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å‹å®šç¾©ãŒä¸å®Œå…¨
def handle_external_api(response: dict[str, Any]) -> None:
    pass

# ãƒ¬ã‚¬ã‚·ãƒ¼ã‚³ãƒ¼ãƒ‰ã®äº’æ›æ€§ç¶­æŒã®å ´åˆ
# TODO: å‹å®‰å…¨åŒ– - ãƒ¬ã‚¬ã‚·ãƒ¼APIå¯¾å¿œã®ãŸã‚
def legacy_adapter(data: Any) -> str:
    return str(data)
```

### Anyå‹ä½¿ç”¨æ™‚ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

1. **å½±éŸ¿ç¯„å›²ã®å±€æ‰€åŒ–**: Anyå‹ã¯é–¢æ•°/ãƒ¡ã‚½ãƒƒãƒ‰ã®å¢ƒç•Œã§å‹å®‰å…¨ãªæ§‹é€ ã«å¤‰æ›ã™ã‚‹
2. **Pydanticæ´»ç”¨**: å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯Pydanticã§æ®µéšçš„ã«ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
3. **TODOã‚³ãƒ¡ãƒ³ãƒˆ**: Anyå‹ä½¿ç”¨æ™‚ã¯å¿…ãšæ”¹å–„è¨ˆç”»ã‚’æ˜è¨˜

```python
# TODO: Anyå‹å½±éŸ¿ç¯„å›²æœ€å°åŒ– - ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹å°å…¥äºˆå®š
def legacy_function(data: dict[str, Any]) -> dict[str, str]:
    return {"result": str(data.get("value", ""))}
```

## å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã®è¨­è¨ˆ

### å…±é€šå‹å®šç¾©ã®å ´æ‰€
- `src/schemas/common_types.py`: å…¨ã‚µãƒ¼ãƒ“ã‚¹å…±é€šã®NewTypeå®šç¾©
- `src/schemas/domain_types.py`: ãƒ‰ãƒ¡ã‚¤ãƒ³å›ºæœ‰ã®å‹å®šç¾©
- `src/schemas/activity_schemas.py`: ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£é–“å¥‘ç´„å®šç¾©

### âœ… é©åˆ‡ãªå‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹
```python
# åŸºæœ¬å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹
type JSONValue = str | int | float | bool | None | list["JSONValue"] | dict[str, "JSONValue"]
type ErrorContext = dict[str, str | int | float | bool | None]

# ãƒ‰ãƒ¡ã‚¤ãƒ³å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹
type SEOSettings = dict[str, str | int | bool]
type TemplateConfig = dict[str, JSONValue]
```

## Pydantic vs TypedDict ã®ä½¿ã„åˆ†ã‘ï¼ˆpylayãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼‰

### Pydanticã‚’å„ªå…ˆçš„ã«ä½¿ç”¨ã™ã‚‹å ´åˆï¼ˆpylayæ¨å¥¨ï¼‰
- **å¤–éƒ¨APIæ¥ç¶š**: ãƒ©ãƒ³ã‚¿ã‚¤ãƒ æ¤œè¨¼ã€è¤‡é›‘ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¿…è¦
- **è¨­å®šç®¡ç†**: ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ã®è‡ªå‹•èª­ã¿è¾¼ã¿ï¼ˆpyproject.tomlèª­ã¿è¾¼ã¿ãªã©ï¼‰
- **ãƒ‡ãƒ¼ã‚¿å¤‰æ›**: è‡ªå‹•çš„ãªå‹å¤‰æ›ãƒ»ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºï¼ˆYAML â†” Pythonå‹å¤‰æ›ï¼‰
- **ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¢ãƒ‡ãƒ«**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’å«ã‚€è¤‡é›‘ãªãƒ¢ãƒ‡ãƒ«
- **å‹ä»•æ§˜å®šç¾©**: TypeSpecã€GraphNodeã€InferResultãªã©
- **JSONã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º**: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆã‚„æ°¸ç¶šåŒ–ãŒå¿…è¦ãªå ´åˆ

### TypedDictã‚’é™å®šçš„ã«ä½¿ç”¨ã™ã‚‹å ´åˆ
- **è»½é‡ãªå†…éƒ¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ **: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒæ¥µã‚ã¦é‡è¦ãªå˜ç´”ãªè¾æ›¸ãƒ™ãƒ¼ã‚¹ã®æ§‹é€ 
- **å¤–éƒ¨APIãƒ¬ã‚¹ãƒãƒ³ã‚¹**: è»½é‡ãªå‹å®šç¾©ãŒå¿…è¦ãªå ´åˆ

```python
# âœ… Pydantic - ãƒ‰ãƒ¡ã‚¤ãƒ³å‹å®šç¾©ï¼ˆæ¨å¥¨ï¼‰
class TypeSpec(BaseModel):
    """YAMLå‹ä»•æ§˜ã®Pydanticãƒ¢ãƒ‡ãƒ«"""
    name: str | None = None
    type: str = Field(..., description="åŸºæœ¬å‹")
    required: bool = True

# âš ï¸ TypedDict - è»½é‡ãªæ§‹é€ å®šç¾©ï¼ˆé™å®šçš„ã«ä½¿ç”¨ï¼‰
class CheckSummary(TypedDict):
    """analyze_issues.pyã®ã‚µãƒãƒªãƒ¼å‹"""
    total_checks: int
    successful_checks: int
```

## ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã®ä½¿ç”¨

### âœ… æ¨å¥¨ã•ã‚Œã‚‹ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹
```python
from collections.abc import Sequence, Mapping

def process_items(items: Sequence[str]) -> list[str]:
    """ä¸å¤‰ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ - èª­ã¿å–ã‚Šå°‚ç”¨"""
    return [item.upper() for item in items]
```

## å‹ãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œ

### ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºã§ã®å‹ãƒã‚§ãƒƒã‚¯
```bash
# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®å‹ãƒã‚§ãƒƒã‚¯
cd backend && make type-check

# ç‰¹å®šã®ãƒ•ã‚¡ã‚¤ãƒ«ã®å‹ãƒã‚§ãƒƒã‚¯
uv run mypy src/repositories/intention_repository.py
```

### CI/CDã§ã®å‹ãƒã‚§ãƒƒã‚¯
- ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ™‚ã«è‡ªå‹•å®Ÿè¡Œ
- `disallow_any_explicit = true` ã§å³æ ¼ãƒã‚§ãƒƒã‚¯

## å‹æ”¹å–„ã®å„ªå…ˆé †ä½

1. **é«˜å„ªå…ˆåº¦**: APIã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€å…¬é–‹é–¢æ•°ã€ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
2. **ä¸­å„ªå…ˆåº¦**: ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã€å†…éƒ¨é–¢æ•°
3. **ä½å„ªå…ˆåº¦**: ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã€ãƒ†ã‚¹ãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆãŸã ã—Anyç¦æ­¢ï¼‰

## å‚è€ƒè³‡æ–™

- [Pydantic Models Documentation](https://docs.pydantic.dev/latest/concepts/models/)
- [Python Typing Documentation](https://docs.python.org/3/library/typing.html)
- [mypy Documentation](https://mypy.readthedocs.io/)
